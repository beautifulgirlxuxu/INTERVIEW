原型：每个函数都有个prototype属性，及原型，每个对象都有个__proto__属性，即隐式原型。
原型链：访问一个对象的属性时，首先会在对象的基本属性中查找，如果没有就沿着__proto__这条链往上查找。
继承：所有对象都可以通过__proto__原型链向上查找得到Object.prototype的所有属性和方法，这就是所谓的继承。
javascript语言继承机制的核心是proto。
A insctanceof B：Instanceof的判断队则是：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。

执行上下文环境：在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。

迭代：每一次对过程的重复就叫一次迭代，每一次迭代的结果是下一次迭代的初始值。
递归：自己调用自己，直到满足条件退出。
Host文件：没有扩展名的Windows系统文件，将一些常用网址的域名与其对应IP地址建立一个“关联”数据库，用户输入网址时，首先会在本地hos文           件中查找有没有对应的ip地址，有就立马打开网页，没有再将网址提交到DNS服务器上解析出域名对应的IP地址。
Ninux：反向代理，当一个网站的访问量越来越大时，将同一应用部署到多台服务器上，客户端请求Ninux，Ninux再请求应用服务器。

浏览器显示HTML的过程（webkit内核）：浏览器解析html构建DOM树，加载CSS文件来构建render树，根据CSS文件对render树进行布局，布局完之后开始绘制render树。
DNS(域名系统或域名服务)：将用户输入的域名地址自动解析为ip地址，计算机有了ip地址才能互相识别、通信。域名一般有2个及以上的DNS,防止一个解析失败，另外一个也可以解析，可以到www.internic.net/whois.html确定域名的DNS。
reflow(回流/重排)：浏览器计算盒模型的位置、大小、字体、颜色等属性。
repain(重绘)：盒模型的位置大小等属性确定后，开始绘制内容。
浏览器在解析html文件时，如果遇到请求外部资源如图片、外链CSS、iconfont字体等，请求异步进行，不会影响渲染线程，但如果是请求js文件，渲染线程会挂起，要等到js文件完全加载并解析完成后才能继续进行渲染线程。
服务器的永久重定向响应：浏览器根据服务器返回的重定向状态码跳转到一个新的URL地址。

栈：表元素的删除和插入操作只能在表尾（栈顶）进行，先进后出（FILO）。
队列：表元素在表尾插入，在表头删除，先进先出（FIFO）。

rem布局原理：等比缩放，一般基于UE图的宽度。根据html根元素字体大小对全局字体大小做一个等比缩放。

Math.abs(x)：取x的绝对值。
Math.round(x)：取x四舍五入后最接近的一个整数。

三栏布局：左右宽度固定，中间宽度自适应。（多种布局方式，如圣杯布局、双飞翼布局、流体布局、绝对定位布局、flex布局）
UED：用户体验设计。

事件阶段：捕获、执行目标元素的监听函数、冒泡。
事件委托（代理）：避免对具体节点添加事件监听器，将监听器添加在父元素上，通过事件冒泡原理，将事件添加到父元素上，触发执行效果。

前端性能优化的方法：
    （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。
    （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
    （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
    （4） 当需要设置的样式很多时设置className而不是直接操作style。
    （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。
    （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。
    （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。
    （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
    对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。

虚拟dom：用js对象代表的一个节点，叫VNode，页面每次渲染都会生成一个新的VNode，两个VNode进行对比，根据对比结果去修改真实的dom。
虚拟dom经过diff算法再patch到页面上。

Vue服务端渲染（SSR）：将Vue实例在服务端渲染成HTML字符串，将他们直接发送给浏览器，最后将静态标记混合为客户端上完全交互的应用程序。
pwa：能让我们开发的web应用能像原生app一样使用。

ES6：箭头函数，模块化，promise，class，symbols。
map()函数：将原数组根据规则映射到新数组。callback一定要有返回值。不会改变原数组。
filter()函数：对数组执行一次指定的回调函数，返回一个新数组，新数组的元素都是执行了回调函数返回值为true的原数组元素。
indexOf()：查找符合条件的元素并返回该元素的索引值。元素不存在返回-1。lastIndexOf()反向搜索。
some()：对数组里面的元素执行一次特定的回调函数，直到函数返回true,若找不到符合条件的，返回false。every()与之相反。

CDN(内容分发网络)：本质上也是一个缓存，将数据缓存在离用户最近的地方，使用户能够以最快的速度获取数据。

vue与jquery的区别：
jquery就是通过选择器($)来选取DOM元素，对DOM元素赋值、取值、绑定事件等，和原生HTML的区别只是在于更加方便地操作DOM元素，数据和页面还是在一起的。
vue通过数据双向绑定来连接view层与model层，通过对数据的操作就能完成对页面视图的渲染。数据与页面分离。

b标签-粗体文本（最后选择）
i标签-斜体文字
em-强调文本
mark-标记文本

块级元素可设置宽高，占一行。
行内元素不可设置宽高，在一行内排列，元素宽度为内容的宽度，可设置line-height，margin、padding上下之无效，左右值有效。
行内块级元素可以设置宽高，在一行排列。

元素隐藏的五种方法：
    opacity：0。视觉上不可见，影响网页布局，可以响应交互。
    display: none。完全消失，盒模型都没有。
    visibility: hidde。视觉上不可见，影响网页布局，不可响应交互。
    position: absolute(top: 9999+ left: 9999+)。可交互，不影响网页布局。
    clip-path: 裁剪图片来隐藏。

同源策略是由Netscape公司于1995年引入浏览器的一种约定，也是浏览器最核心也最基本的安全功能，如果少了同源策略，浏览器很容易受
到XSS、CSFR的攻击。
jsonp跨域原理：动态创建script脚本，再请求一个带参网址。

文本框获取的值都是字符串类型

数据存储方式：
    IndexDB：html5的一种本地存储方式，将一些数据保存在浏览器（客户端）中，断网可以直接访问浏览器里的数据，可以用来做一些离线应用。
    Cookie：通过在浏览器（客户端）记录信息来确定用户身份，大小为4KB。
    Session：是服务端使用的一种记录客户端状态的机制。
    url：参数用的是get方法，从服务器上获取数据，大小不能超过2kb。
    post：向服务器传送数据，数据量较大。
    localstorage：html5的一种本地存储，将数据保存在客户端中，一般是永久保存。

this使用的四个场景：
    1.作为对象的方法调用，this绑定到该对象上；
    2.作为函数调用，this绑定到全局对象上，若让方法里面的内部函数完成某些功能，在方法定义var that = this;
    3.构造器函数调用时，this绑定到通过构造器函数new出来的实例对象上；
    4.apply调用时，apply传入两个参数，第一个是要绑定到this上的值，第二个传入一个参数数组。

Object.key()：返回一个给定对象自身所有可枚举属性和方法的名称组成的数组，与for in 区别在于for in 会枚举原型链上的属性。
访问对象的某个属性用.（object.propertyName）或者object[propertyName]。

数组是同一数据类型的集合，有下标范围，从0开始；而数列是一组有规律的数字。


优化CSS图片加载技术：CSS sprite、SVG sprite、Base64
CSS选择器权重问题：！important（infinity） > 行间样式（1000） > id选择器（100） > class选择器||属性选择器（10） > 标签选择器（1） > 通配符选择器*（0）

browser-sync start --server './'  --files '*.html,css/*.css,js/*.js'

Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。

用vue实现双向数据绑定时，劫持数据结合订阅发布者模式，将数据转化为getter、setter函数，对数据对象进行重写，当数据是数组时，将修改后的可以监听变化的数组方法直接覆盖数组原型上的一些原生方法。

所有没有用var、let、const声明的变量都是全局变量，匿名函数也是闭包，能在全局里面直接访问。

new的过程中发生了什么：
    /以上面的Student为例
    var ob = new Object();           // 新建一个对象
    ob.__proto__ = Student.prototype; //设置新对象的原型链
    Object.call(ob);                  // 让Student的this指向实例ob，执行constructor函数。执行构造器里面的代码
    sudent = ob         //返回这个实例对象

一个组件的data必须是函数，这样实例可以维护一份被返回对象的独立拷贝，实例之间不会受影响。

gulp 只是个 task runner，底层只是 node 脚本，不包括模块化的能力，如果需要模块化需要引入另外的框架（比如 requirejs），而 wepack 则本身就是为了模块化而出现的，压缩合并只是它附带的功能

URI（uniform resource identifier）：统一资源标识符。用来标识互联网上的资源（例如，网页或文件）和怎样访问这些资源的传输协议（例如，HTTP 或 FTP）的字符串。
URL（uniform resource locato）：统一资源定位器。是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。
URN（uniform resour name）：统一资源命名，是通过名字来标识资源。也是URI的一种。
encodeURI 和 decodeURI 函数操作的是完整的 URI；这俩函数假定 URI 中的任何保留字符（其中斜体的名字代表组件；“:”, “/”, “;”，“?”是当作分隔符的保留字符）都有特殊意义，所有不会编码它们。
encodeURIComponent 和 decodeURIComponent 函数操作的是组成 URI 的个别组件；这俩函数假定任何保留字符都代表普通文本，所以必须编码它们，所以它们（保留字符）出现在一个完整 URI 的组件里面时不会被解释成保留字符了。

一个shim是一个库,它将一个新的API引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现。
一个polyfill就是一个用在浏览器API上的shim.我们通常的做法是先检查当前浏览器是否支持某个API,如果不支持的话就加载对应的polyfill，然后新旧浏览器就都可以使用这个API了。

==和!==比较若类型不同，先偿试转换类型，再作值比较，最后返回值比较结果 。而===和!==只有在相同类型下,才会比较其值。

DOM：文档对象模型，描述处理网页内容的方法和接口。
BOM：浏览器对象模型，描述了与浏览器交互的方法和接口。

浅拷贝：原对象和拷贝对象共用一份引用，对任何一个对象改变都会影响到另一个对象。
深拷贝：原对象和拷贝对象互相独立，改变其中任何一个对象都不会影响到其他对象。

函数式编程是通过巧妙的变化、组合、使用函数而实现编写更加简洁代码的方式。将一个大问题分解成一系列函数，用数学思想来解决问题，让代码自动执行，而不是通过程序员手动操作每一步，改变状态。
高阶函数：以其它函数为输入，或者返回一个函数为输出的函数。
纯函数：返回的计算结果仅与传入的参数相关。这里不会使用外部的变量和全局状态，并且没有副作用。 换句话说就是不能改变作为输入传入的变量。所以，程序里只能使用纯函数返回的值。纯函数是对数学上的“函数”的真实演绎，就是输入和输出的关系。
匿名函数（lambda表达式）：允许了在现场定义临时逻辑的能力。 通常这带来的好处就是方便：如果一个函数只用一次，没有必要给它浪费一个变量名。缺点：在调试栈中难以识别，不利于调试。

SPA: 单页应用，在和用户交互的时候当用户点击某个物件或者按键的时候不会跳转到其他的页面，会像app一样在当前页面进行跳转。
缺点：不利于SEO，首次加载时间比较长，前进、后腿、地址栏管理起来比较复杂。

transion：translate、rotate、scale。精简版的animation，动画过程不能暂停，从一个点到另一个点的线性变化，不能循环。
animation: 动画可以循环、暂停。

SVG
　　　　SVG 是一种使用 XML 描述 2D 图形的语言。
　　　　SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。
　　　　在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
　　　　特点：
　　　　	　　不依赖分辨率
　　　　	　　支持事件处理器
　　　　	　　最适合带有大型渲染区域的应用程序（比如谷歌地图）
　　　　　　	复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
　　　　	　　不适合游戏应用
　　Canvas
　　　　Canvas 通过 JavaScript 来绘制 2D 图形。
　　　　Canvas 是逐像素进行渲染的。
　　　　在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。
　　　　特点：
　　　    　　依赖分辨率
　　　　	　　不支持事件处理器
　　　　　　	弱的文本渲染能力
　　　　　　	能够以 .png 或 .jpg 格式保存结果图像
　　　　	　　最适合图像密集型的游戏，其中的许多对象会被频繁重绘